<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>HA#2_IIT6028</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script>
    </script>
    <style>
    @import url(http://fonts.googleapis.com/earlyaccess/notosanskr.css);
    body {
      font-family: 'Noto Sans KR', sans-serif;
    }

    .container {
      padding-bottom: 20px;
    }

    .title {
      margin-top: 30px;
    }
    .student-info {
      float: right;
      text-align: right;
    }

    hr {
      width: 100%;
    }

    #main-carousel {
      width: 1000px;
      left: 50%;
      margin-left: -500px;
      margin-top: 30px;
    }

    h3 {
      margin-top: 40px;
      margin-bottom: 20px;
    }

    img.results_img {
      width: 100%;
    }

    .copyright-hr {
      margin-top: 100px;
    }
    .copyright {
      float: right;
      text-align: right;
      font-size: 12px;
    }

    </style>
  </head>
  <body>

    <div class="container">

      <div class="title">
        <h1>IIT6028 HA#2&nbsp;<small>Computational Photography</small></h1>
      </div>

      <div class="student-info">
        <p>2018314405 Park Jun Hyuk</p>
        <p><a href="http://mcml.yonsei.ac.kr/">MCML Group</a> @ <a href="http://www.yonsei.ac.kr/sc/index.jsp">Yonsei Univ.</a></p>
        <p><a href="https://github.com/PJunhyuk">GitHub</a> / <a href="http://parkjunhyuk.com">Website</a></p>
      </div>

      <hr/>

      <h1>Eulerian Video Magnification</h1>

      <hr/>
      <h3>1. INITIALS AND COLOR TRANSFORMATION<br/><small>load the video, extract its frames, convert to double-precision, and convert to YIQ from RGB</small></h3>

      <p>Using <a href="https://github.com/PJunhyuk/IIT6028/blob/master/A2/A2.m">video_to_frame_list</a> function.</p>
      <p>Load the video file using <code>VideoReader</code> function, extract its frame using <code>readFrame</code> function.</p>
      <p>And convert each of the frames to the YIQ color space using <code>rgb2ntsc</code> function.</p>

      <br/>
      <img class="results_img" src="./img/img_1_original_vs_yiq.png" alt="img_1_original_vs_yiq">
      <p><i>[1 2] 1: frame #1 original / 2: frame #1 only Y from YIQ</i></p>
      <br/>

      <p><a href="https://en.wikipedia.org/wiki/YIQ">YIQ</a> in WIKIPEDIA</p>
      <p>In YIQ color space, Y component represents the luma information, and is the only component used by black-and-white television recievers.</p>
      <p>I and Q represent the chrominance information.</p>
      <p>So I just use Y component in this project.</p>
      <br/>
      <p>Total required time: </p>
      <p>It takes quite a lot of time. Because we have to apply all processes in every frames.</p>

      <hr/>
      <h3>2. LAPLACIAN PYRAMID<br/><small></small></h3>

      <p>Using <a href="https://github.com/PJunhyuk/IIT6028/blob/master/A2/A2.m">get_laplacian_pyramid</a> function.</p>
      <p><code>get_laplacian_pyramid</code> function gets <code>image_original</code>.</p>
      <p>And it apply gaussian filter on it, to generate <code>image_blurred</code>.</p>
      <p>When applying gaussan filter, I set <code>gaussian_stdev</code> as 2.</p>
      <p>Then calculate <code>image_residual</code> as <code>image_origianl - image_blurred</code>.</p>
      <p>I made it as function to repeat this process easily.</p>
      <br/>

      <p>We can easily figure out <code>image_gaussian_N</code> is 2^N smaller then original image.</p>
      <p>And <code>image_residual_N</code> is 2^N smaller then original image.</p>
      <p>So each cycle, we generate <code>image_gaussian_N+1</code> and <code>image_residual_N</code> from <code>image_guassian_N</code>.</p>
      <br/>

      <p>In this project, I applied laplacian pyramid twice, so generated guassian_1, guassian_2, residual_0, residual_1.</p>
      <p>You can check it by following image. All results are matched with size of original frame, using <code>imresize</code> function in matlab.</p>
      <p><code>imresize</code> function uses bicubic interpolation to upsample it.</p>

      <br/>
      <img class="results_img" src="./img/img_2_laplacian_pyramid.png" alt="img_2_laplacian_pyramid">
      <p><i>[1 4 / 2 5 / 3 -] 1: frame_original / 2: gaussian_1(*2) / 3: gaussain_2(*4) / 4: residual_0 / 5: residual_1(*2)</i></p>
      <br/>

      <p>And we can reconstruct original image from low level of gaussian & residual images.</p>
      <p>We can reconstruct <code>image_reconstruct_N</code> from <code>image_gaussian_N+1</code> and <code>image_residual_N</code>.</p>
      <p>Just generate <code>image_gaussian_up</code> from upsampling <code>image_gaussian_N+1</code> using <code>imresize</code> function.</p>
      <p>And add <code>image_gaussian_up</code> and <code>image_residual_N</code> for generate <code>image_reconstruct</code>.</p>

      <br/>
      <img class="results_img" src="./img/img_2_recontruct.png" alt="img_2_recontruct">
      <p><i>[1 2] 1: frame_original / 2: reconstructed image by image_residual_0, image_residual_1, image_gaussian_2</i></p>
      <br/>

      <p>We can check original image and reconstructed image by laplacian pyramid is almost same.</p>

      <hr/>
      <h3>3. TEMPORAL FILTERING<br/><small></small></h3>

      <hr/>
      <h3>4. EXTRACTING THE FREQUENCY BAND OF INTEREST<br/><small></small></h3>

      <hr/>
      <h3>5. IMAGE RECONSTRUCTION<br/><small></small></h3>

      <p>First, I generate <code>cube</code> for gaussian & residual images by using <code>get_cube</code> function. It means temporal set of images.</p>
      <p>For each pixels in image, I generated vector called <code>cube_pixel</code>. It is composed up each value of the pixel in the all frames.</p>
      <p>Then apply <code>butterworthBandpassFilter</code> to each of them, and reconstruct <code>cube</code> with their results. It's on <code>get_cube_f_s</code> function.</p>
      <p>I could figure out values of results become too small, so we have to upscale them.</p>
      <p>I used <code>[min(image(:)) max(image(:))]</code> to scaling the display based on the range of pixel values in image.</p>
      <p>For variables in codes, <code>_f</code> means filtered, and <code>_s</code> means upscaled.</p>
      <br/>

      <p>Finally we have to reconstruct original <code>cube_f_s</code> from gaussian & residual <code>cube_f_s</code>.</p>
      <p>We can use </p>

      <p></p>

      <p><br/><i>You can check full matlab codes in <a href="https://github.com/PJunhyuk/IIT6028/tree/master/A1/web">GitHub Repo</a>.</i></p>

      <hr class="copyright-hr"/>

      <div class="copyright">
        <p><a href="https://github.com/PJunhyuk/IIT6028/tree/master/A2/web">GitHub Repo</a></p>
        <p>Copyright 2018. PJunhyuk. All rights reserved.</p>
      </div>

    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
    <!-- <script src="bootstrap.js"></script> -->
  </body>
</html>
